## 静态页面与交互问题和解决方案 🤝

#####作者：宣正吉
**梗概：** 静态页面设计过程中遇到的问题和解决方案汇总。

---

**1. antd 原生菜单怎么实现选中一个菜单项之后，其它菜单项收起？**
解决：一般来说不会出现这种情况，组件内已经定义好了 UI 点击事件，解决问题 2 的同时这个问题也完美解决了。

**2. 两个导航栏同时被选中怎么办？如何处理这种冲突？**
解决：第二个菜单可以只保留样式，去除菜单子项，作为类似按钮的点击操作。

**3. 侧边导航点击展开时有问题，各个组件大小超过了边界。**
解决：导航组件的定位有问题，将定位设置为`static`可以解决此问题。

**4. Antd 在开发模式进行样式编写，但是在编译过程中被覆盖失效，导致做好的页面样式缺失。**
解决：参考`https://blog.csdn.net/hzxOnlineOk/article/details/121016591`，在 ant design 中想要覆盖原生组件的样式，因为 CSS modules 的使用会使得 class 的名字被重新编译而没有效果；对此我们可以使用全局 css 来达到目的。必须通过一定手段在项目中能使用 less。
但是上面的方法似乎在 nextjs 中收到 css 引用的限制无法实现，最终用`!important`解决了此问题。

**5. 悬浮下拉菜单的样式覆盖有问题。**
解决：加上悬浮类名`ant-dropdown-menu-item-active`可修改 hover 样式。

**6. Antd 的包裹组件失效？** 包裹组件`App`必须在`App`组件之下才能生效，此处没有效果，可以通过其它组件实现，例如弹窗或者气泡等等。

**7. `footer`写完之后发现登陆页面被拉的老长……黑人问号？**
解决：排错，先去掉其对应样式表，观察有没有恢复，没恢复说明是别的地方覆盖了，修改样式之后，刷新又好了，黑人问号\*2。
**8. `antd`导航和`nextjs`路由的结合，点击菜单项显示不同页面，好像做不到……**
解决：路由只能跳转到新的页面，并重新刷新整个线程，似乎无法做到页面内导航，只能通过传递 state 改变页面状态
**9. 酒店页面的城市选择器和日期选择器紧紧挨在一起的效果怎么实现？**
解决：采用`antd`当中的`Space.Compact`实现。
**10. 日期选择器语言为英文怎么办？**
解决：利用`antd`的国际化功能，配合`ConfigProvider`组件。
**11. 时间选择器默认日期为当前怎么设置？**
解决：利用`moment`包实现，可获取当前时间并格式化，很方便，而且可以设置偏移天数等。
**12. 大轮播图的绝对定位有问题** ，定位后有很大偏移，需要通过`translate`调整位置。
**13. 推荐模块轮播图的箭头不见了**
解决：通过查看 API 对应表找到解决方法，设置箭头显示并添加想要的效果。
**14. Tab 的长度不一样怎么办？想要不改变 css 的情况下充满整个父组件。**
解决：通过改变 label 属性解决，label 属性其实可以输入一个 react 组件的。
**15. 选择器怎么在列表项之前添加对勾？**
解决：通过表单的选择项加判断渲染对勾，且对勾要做绝对定位，否则对勾会导致后面文本位置偏移。

    ```jsx
    {
    value: "头等舱",
    label: (
    <div className="air-options">
    {type == "头等舱" ? (
    <CheckOutlined className="air-option-icons"></CheckOutlined>
    ) : (
    ""
    )}
    <div className="air-op">头等舱</div>
    </div>
    ),
    },
    ```

**16. 城市选择器复用的时候样式 css 修改不了？**
解决：选择器格式有误，一定要严格按照 F12 的结果写选择器序列。
**17. 数据请求异步和渲染的同步问题**
解决：请求数据是异步操作，当数据还未请求成功时，初始化渲染的时候组件获得的数据为空，这时取数据就取不到，需要判断数据是否存在而后再渲染。
**18. 骨架屏中图片怎么展示？**
解决：直接把背景色设为灰色，可以确保没加载出来时展示占位。
**19. `Uncaught TypeError: destroy is not a function at commitHookEffectListUnmount`**
解决：react 的`useEffect`函数不能是异步的，其返回值只能是清理用的，所以一定将初始化异步函数（这里是加载数据），放入一个单独的函数当中再放进`useEffect`。
**20. 渲染次数超过最大限度警告：**
解决：`useEffect`内部不要调用 useState，否则当 state 变化时，会不停地更新组件，不断请求数据，导致网络和渲染问题。
**21. 如何解决初始化下拉菜单等组件时依靠异步数据，渲染空白的问题？**
解决：这个问题是由于`useEffect`设置导致的，初始化时由于请求是异步操作，直接在请求后面获得数据是空的，即使后面新的数据到了改变了 data 的 state，但是由于 list 的 state 没有变化，所以状态不更新，导致加载不出列表。
**22. 导航点击之后虽然能路由跳转但是导航栏组件消失，怎么解决？**
解决：将主页抽出当作一个组件，每个页面引用该组件，将页面内容抽出当作另外一个组件作为参数传入该组件可实现有导航栏的路由。
**23. 导航栏 mock 怎么把图标和数据联系在一起？**
解决：可以用 antd 的 type 字段作为 mock 数据请求到页面中。
**24. 导航栏中采用公共页面的导航项目无法设置所选键？**
解决：除了本地存储上一次点击的选项外，还可通过路由带请求参数的方式将页码放在 url 中，页面通过当前路由获取所选择的 key
**25. 如何通过正则表达式获取 url 中的参数？**
解决：可通过`window.location.search`获得当前的查询参数，用正则表达式提取参数值用于设置选择的项目对象。
**26. 组件渲染时 window 变量还不存在** ，只能用`useEffect`将要执行的操作包裹，其会在组件挂载完毕时执行一次，window
还存在。
**27. 似乎使用 nextjs 中的 Image 组件可以自动优化图片的加载过程。**
**28. 黑夜模式切换时，主页组件每次路由重新刷新，开关状态置零后失效怎么办？**
解决：用 Storage 进行存储，每次设置开关，既要设置状态，也要设置本地存储，组件挂载时从本地存储中读取设置的值。
**29. 当跳转到同一个路由时，页面组件就不更新，导航栏无法通过传递过去的查询参数设置导航栏选择的位置怎么办？**
解决：这个问题和 useEffect 执行的时机和 router 的属性有关，如果 useEffect 不设置，也就是传入参数为空数组， useEffect 相当于 ComponentDidMount 周期函数，在组件挂载后一段时间内执行，如果传入依赖参数，则在组件更新后和销毁前执行，我这里设置的是空数组，但是 router 的路由没发生变化，虽然查询参数变了，但是页面组件更新时 useEffect 就没有发生任何变化，也就不能处理参数，将空字符串改为 router 可以解决该问题。
**30. 点击发送验证码倒计时问题，计时器不能自己销毁：**

```js
// 点击获取验证码操作
const handlePhone = () => {
  // 验证表单操作
  form
    .validateFields(["phonenum"])
    .then(() => {
      // 验证成功后发送随机验证码
      showMessage();
      // 设置按钮为 disabled
      setDisabled(true);
      setCountdown(10);
      // 每秒减少倒计时的值
      const intervalId = setInterval(() => {
        if (countdown == 0) {
          clearInterval(intervalId);
          setDisabled(false);
        }
        setCountdown((countdown) => countdown - 1);
      }, 1000);

      // // 倒计时结束后重置状态
      // setTimeout(() => {
      //   clearInterval(intervalId);
      //   setCountdown(60);
      //   setDisabled(false);
      // }, 60000);
    })
    .catch((err) => {
      showMessage(err);
    });
};
```

解决：这样写计时器不会销毁的原因是因为 setInterval 函数在每次组件重新渲染时都会重新执行，但是计时器的引用并没有被保存在状态或变量中，因此无法在组件卸载时停止计时器。这会导致计时器继续运行，即使组件已经被卸载，也会导致内存泄漏和性能问题。
每次重新渲染时，都会创建一个新的闭包环境，其中包含当前状态和变量的旧值。因此，当计时器回调函数被执行时，它会使用旧的 countdown 值，而不是最新的值。为了解决这个问题，需要使用函数式更新来确保在更新状态时使用最新的 countdown 值。
